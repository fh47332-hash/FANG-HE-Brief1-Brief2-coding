<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Merged ECG + GSR Ball (Adjusted)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<style>
  body{margin:0;background:#0b0c0d;color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
  #connect{position:absolute;left:16px;top:16px;padding:10px 14px;border-radius:8px;border:none;background:#fff;color:#000;cursor:pointer;z-index:10}
  #info{position:absolute;left:16px;bottom:16px;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px;font-size:25px;z-index:10}
  #alert{position:absolute;right:16px;top:16px;padding:10px 14px;border-radius:8px;background:rgba(255,0,0,0.12);color:#ffb3b3;font-weight:600;z-index:10}
  #ecgLegend{position:absolute;left:16px;bottom:60px;color:#ddd;font-size:25px;z-index:10;background:rgba(0,0,0,0.25);padding:6px;border-radius:6px}
</style>
</head>
<body>
  <button id="connect">Connect</button>
  <div id="alert" style="display:none">BPM mismatch</div>
  <div id="info">BPM: —   est(window): —   est(interval): —   Beat: —   GSR: —</div>
  <div id="ecgLegend">ECG: real-time raw trace (drawn through the ball) — GSR controls color/size</div>

<script>
/* ---------------- SETTINGS ---------------- */
const BAUD = 115200;
const WINDOW_SEC = 10;         // 窗口秒数用于窗口估算
const INTERVAL_COUNT = 6;      // 最近 N 次间隔用于 interval 估算
const MISMATCH_THRESHOLD = 15; // bpm 差异阈值
const MIN_BEAT_GAP_MS = 250;   // 去抖
const ECG_BUFFER_LENGTH = 800; // ECG 缓冲点数（决定滚动平滑度）

/* GSR mapping & smoothing */
const MAP_MIN = 230;
const MAP_MAX = 240;
let SMOOTHING = 0.6;
let RISE_DECAY = 0.02;

/* -------------- SERIAL STATE --------------- */
let port = null, reader = null;
let decoder = null;

let arduinoBPM = null;
let beatState = 0;       // 当前解析到的 beat(0/1)
let lastRecordedBeatTime = 0;

// ECG buffer (原始模拟值 0..1023)
let ecgBuffer = new Array(ECG_BUFFER_LENGTH).fill(512);

// timestamps & intervals
let beatTimestamps = [];
let intervals = [];

/* estimates */
let estBPM_window = null;
let estBPM_interval = null;
let mismatch = false;

/* GSR state */
let latestValue2 = null;
let latestContact = 0;
let riseStrength = 0;
let targetSmooth = 0;

/* visual state */
let jump = 0;           // current jump amount 0..1
let targetJump = 0;     // target value (0..1)
let lastBeatVisual = 0; // 上一次用于视觉触发的 beat time

// smooth size
let sizeSmooth = 1.0;

/* DOM */
const btn = document.getElementById('connect');
const info = document.getElementById('info');
const alertBox = document.getElementById('alert');
btn.onclick = connectSerial;

/* ---------------- Serial / Parser ---------------- */
async function connectSerial(){
  if (!('serial' in navigator)) {
    alert('请使用支持 Web Serial 的浏览器（Chrome / Edge）并通过 HTTPS/localhost 打开页面。');
    return;
  }
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: BAUD });
    btn.disabled = true;
    btn.textContent = 'Connected';
    if (window.TextDecoderStream) {
      const tds = new TextDecoderStream();
      port.readable.pipeTo(tds.writable);
      reader = tds.readable.getReader();
      decoder = null;
    } else {
      decoder = new TextDecoder();
      reader = port.readable.getReader();
    }
    readLoop();
  } catch (e) {
    console.error(e);
    alert('打开串口失败：' + (e.message || e));
  }
}

async function readLoop(){
  let buffer = '';
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      if (!value) continue;
      const chunk = (typeof value === 'string') ? value : decoder.decode(value, { stream: true });
      buffer += chunk;
      const lines = buffer.split(/\r?\n/);
      buffer = lines.pop();
      for (const line of lines) parseLine(line.trim());
    }
  } catch (e) {
    console.error('readLoop error', e);
  } finally {
    try { reader.releaseLock(); } catch(e){}
  }
}

// 解析 Arduino 输出行（同时支持 ECG 与 GSR 的标记）
function parseLine(line){
  if (!line) return;
  const mRaw = line.match(/RAW\s+(\d+)/i);
  const mBPM = line.match(/BPM\s+(-?\d+)/i);
  const mBeat = line.match(/Beat\s+([01])/i);
  const m2 = line.match(/Value2\s+(-?\d+)/i);
  const mc = line.match(/Contact\s+([01])/i);
  const now = Date.now();

  if (mRaw) {
    const raw = parseInt(mRaw[1], 10);
    pushECG(raw);
  }
  if (mBPM) {
    arduinoBPM = parseInt(mBPM[1], 10);
  }
  if (mBeat) {
    const b = parseInt(mBeat[1], 10);
    if (b === 1 && beatState === 0) {
      if (now - lastRecordedBeatTime >= MIN_BEAT_GAP_MS) {
        beatTimestamps.push(now);
        const n = beatTimestamps.length;
        if (n >= 2) {
          const interval = beatTimestamps[n-1] - beatTimestamps[n-2];
          intervals.push(interval);
          if (intervals.length > INTERVAL_COUNT) intervals.shift();
        }
        lastRecordedBeatTime = now;
        lastBeatVisual = now;
      }
    }
    beatState = b;
    pruneOldTimestamps();
    computeEstimates();
  }

  if (m2) latestValue2 = parseInt(m2[1], 10);
  if (mc) latestContact = parseInt(mc[1], 10);
}

/* --------------- Estimation & ECG buffer -------------- */
function pushECG(raw) {
  ecgBuffer.push(raw);
  if (ecgBuffer.length > ECG_BUFFER_LENGTH) ecgBuffer.shift();
}

function pruneOldTimestamps(){
  const now = Date.now();
  const cutoff = now - WINDOW_SEC*1000;
  beatTimestamps = beatTimestamps.filter(t => t >= cutoff);
}

function computeEstimates(){
  pruneOldTimestamps();
  const count = beatTimestamps.length;
  if (count === 0) estBPM_window = null;
  else estBPM_window = (count / WINDOW_SEC) * 60.0;

  if (intervals.length === 0) estBPM_interval = null;
  else {
    let sum = 0;
    for (let i = 0; i < intervals.length; i++) sum += intervals[i];
    const avgInterval = sum / intervals.length;
    estBPM_interval = avgInterval > 0 ? 60000.0 / avgInterval : null;
  }

  mismatch = false;
  if (arduinoBPM !== null && arduinoBPM > 0 && estBPM_window !== null) {
    const diff = Math.abs(arduinoBPM - estBPM_window);
    if (diff >= MISMATCH_THRESHOLD) mismatch = true;
  }
}

/* ---------------- p5.js 绘图 ---------------- */
let ecgCanvasHeight;
let ecgTop, ecgBottom;
let ecgScale = 1;

function setup(){
  createCanvas(windowWidth, windowHeight);
  noStroke();
  textFont('sans-serif', 14);
  frameRate(60);

  // ECG strip will be centered vertically so it crosses the ball
  ecgCanvasHeight = Math.round(height * 0.28);
  ecgTop = (height - ecgCanvasHeight) / 2;
  ecgBottom = ecgTop + ecgCanvasHeight;
}

function draw(){
  background(10);

  // 背景区域（ECG 背景仍在后面）
  drawECGBackground();

  // --- GSR: 计算 strength (0..1) with smoothing & contact ---
  const rawTarget = computeGsrTarget();
  const target = (latestContact === 1) ? rawTarget : 0;

  // smoothing layers (preserve your original dynamics)
  riseStrength += (target - riseStrength) * SMOOTHING;
  if (target === 0) riseStrength = Math.max(0, riseStrength - RISE_DECAY);
  targetSmooth += (riseStrength - targetSmooth) * 0.2;
  const gsrStrength = targetSmooth; // 0..1

  // --- BPM: determine tempo for jump ---
  const preferredBPM = (estBPM_interval !== null) ? estBPM_interval : (estBPM_window !== null ? estBPM_window : arduinoBPM || 60);
  const bpmForSpeed = (preferredBPM && preferredBPM > 0) ? preferredBPM : 60;

  // visual beat trigger
  const now = Date.now();
  const timeSinceVisual = now - lastBeatVisual;
  if (timeSinceVisual <= 450) {
    targetJump = Math.max(0.9 - (timeSinceVisual / 450), 0.1);
  } else {
    const period = 60000.0 / bpmForSpeed;
    const t = (millis() % period) / period;
    targetJump = 0.04 + 0.18 * (0.5 - Math.abs(t - 0.5)) * 2.0;
  }

  // adjust jump speed based on bpm
  const speedFactor = map(constrain(bpmForSpeed, 40, 180), 40, 180, 0.12, 0.6);
  jump += (targetJump - jump) * speedFactor;

  // --- Ball drawing parameters ---
  const maxJump = min(width, height) * 0.10;         // 减小垂直跳动幅度
  const centerY = height * 0.5;                      // 放到画面中间，方便 ECG 通过
  const y = centerY - maxJump * jump;

  // size: reduced max, smoother interpolation
  const baseRad = min(width, height) * 0.18;        // 略小基础半径
  const sizeTarget = 1 + gsrStrength * 0.28 + jump * 0.06; // 控制最大放大比例更小
  sizeSmooth += (sizeTarget - sizeSmooth) * 0.08;   // 慢速平滑，使变化更温和
  const finalRad = baseRad * sizeSmooth;

  // color: from white (s=0) to cyan-blue (s=1), preserve white at s=0
  // lerp between white and target blue-ish color
  const sr = 255;
  const sg = 255;
  const sb = 255;
  const tr = 30;
  const tg = 150;
  const tb = 255;
  const r = Math.round(lerp(sr, tr, gsrStrength) * (1 - 0.10*jump) + 0*0);
  const g = Math.round(lerp(sg, tg, gsrStrength) * (1 - 0.05*jump) + 0*0);
  const b = Math.round(lerp(sb, tb, gsrStrength) * (0.6 + 0.4*gsrStrength));

  fill(r, g, b);
  noStroke();
  ellipse(width/2, y, finalRad * 2);

  // --- Draw ECG wave ON TOP of the ball so it '穿过'效果明显 ---
  drawECGWaveOverBall();

  // HUD 显示
  fill(255);
  textAlign(LEFT);
  const arduinoText = (arduinoBPM === null) ? '—' : arduinoBPM;
  const wText = (estBPM_window === null) ? '—' : estBPM_window.toFixed(1);
  const iText = (estBPM_interval === null) ? '—' : estBPM_interval.toFixed(1);
  const beatText = beatState;
  const valText = (latestValue2 === null) ? '—' : latestValue2;
  const contactText = latestContact;
  const txt = `BPM: ${arduinoText}   est(window ${WINDOW_SEC}s): ${wText}   est(interval): ${iText}   Beat: ${beatText}   GSR:${valText} contact:${contactText} strength:${gsrStrength.toFixed(3)}`;
  text(txt, 20, 32);
  info.innerText = txt;

  // mismatch 提示
  if (mismatch) {
    alertBox.style.display = 'block';
    alertBox.textContent = `BPM mismatch! Arduino:${arduinoText}  est:${(estBPM_window||0).toFixed(1)}`;
  } else {
    alertBox.style.display = 'none';
  }

  // beats count
  fill(200);
  textAlign(RIGHT);
  text(`beats in ${WINDOW_SEC}s: ${beatTimestamps.length}`, width - 20, 32);
}

function drawECGBackground(){
  // subtle background band where ECG sits (behind everything)
  fill(18);
  rect(12, ecgTop - 10, width - 24, ecgCanvasHeight + 20, 8);

  // fine grid (kept subtle)
  strokeWeight(1);
  stroke(30);
  for (let x = 12; x < width - 12; x += 20) {
    line(x, ecgTop, x, ecgBottom);
  }
  for (let y = ecgTop; y <= ecgBottom; y += 20) {
    line(12, y, width - 12, y);
  }
  noStroke();
}

function drawECGWaveOverBall(){
  // draw ECG path across full width, on top of the ball (cyan, thick)
  const left = 20;
  const right = width - 20;
  const w = right - left;
  const step = w / (ECG_BUFFER_LENGTH - 1);
  const center = (ecgTop + ecgBottom) / 2;
  const amp = (ecgCanvasHeight / 3.4);

  strokeWeight(4);               // 加粗
  stroke(0, 200, 255);          // 青色
  noFill();
  beginShape();
  for (let i = 0; i < ecgBuffer.length; i++) {
    const raw = ecgBuffer[i];
    const v = (raw - 512) / 512.0;
    const vy = center - v * amp;
    const x = left + i * step;
    vertex(x, vy);
  }
  endShape();
  noStroke();
}

/* GSR helper */
function computeGsrTarget() {
  if (latestValue2 === null) return 0;
  let s = (latestValue2 - MAP_MIN) / (MAP_MAX - MAP_MIN);
  return Math.max(0, Math.min(1, s));
}

/* ---------------- utilities ---------------- */
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  ecgCanvasHeight = Math.round(height * 0.28);
  ecgTop = (height - ecgCanvasHeight) / 2;
  ecgBottom = ecgTop + ecgCanvasHeight;
}

// simple lerp
function lerp(a, b, t){ return a + (b - a) * t; }

window.addEventListener('beforeunload', async () => {
  try {
    if (reader) await reader.cancel();
    if (port) await port.close();
  } catch(e){}
});
</script>
</body>
</html>
